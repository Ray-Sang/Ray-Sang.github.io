<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ray-sang.github.io</id>
    <title>Ray&apos;s Space</title>
    <updated>2020-10-11T14:29:25.442Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ray-sang.github.io"/>
    <link rel="self" href="https://ray-sang.github.io/atom.xml"/>
    <subtitle>Plain living and high thicking</subtitle>
    <logo>https://ray-sang.github.io/images/avatar.png</logo>
    <icon>https://ray-sang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Ray&apos;s Space</rights>
    <entry>
        <title type="html"><![CDATA[硬件仿真课程作业-gcd]]></title>
        <id>https://ray-sang.github.io/post/ying-jian-fang-zhen-ke-cheng-zuo-ye-gcd/</id>
        <link href="https://ray-sang.github.io/post/ying-jian-fang-zhen-ke-cheng-zuo-ye-gcd/">
        </link>
        <updated>2020-10-11T12:38:14.000Z</updated>
        <summary type="html"><![CDATA[<p>要求：<br>
设计一个电路，实现最大公约数计算。</p>
]]></summary>
        <content type="html"><![CDATA[<p>要求：<br>
设计一个电路，实现最大公约数计算。</p>
<!-- more -->
<p>例程对应的entity结构为：</p>
<pre><code class="language-vhdl">entity gcd is

    port

    (

        clock, new_input : in std_logic;

        a, b   : in  unsigned(15 downto 0);

        result : out unsigned(15 downto 0):=to_unsigned(0,16);

        busy   : out std_logic

    );

end;
</code></pre>
<p>各个信号功能说明如下：<br>
Clock：时钟，在它的上升沿作用下进行数据计算<br>
New_input：该信号=’1’时，表示需要在clock上升沿输入待计算的两个数a和b<br>
Result: 运算结果，当busy=‘0‘时输出最新的运算结果<br>
Busy: 表明当前电路处于运算中，还是运算完成，它为‘1’的时候表明运算尚未完成，此时result的内容不可用，但它为’0’时，表明运算结束，此时result存放的是运算结果（最近一次new_input=‘1‘时输入数据a和b的最大公约数）</p>
<p>tb的结果应该为：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd.png" alt="" loading="lazy"></p>
<p>我的程序：</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end gcd;

architecture rtl of gcd is
    -- fill you code here
begin
    process(clock)
    -- fill your code
    variable flag : boolean := false;
    variable n1, n2 : unsigned(15 downto 0);
    
    begin
        if rising_edge(clock) then

            if (new_input = '1') then
                n1 := a;
                n2 := b;
                busy &lt;= '1';
                flag := true;
            end if;

            if (n1 = 1 or n2 = 1) then -- consider when a or b = 1, then gcd is always 1
            	flag := false;
            	busy &lt;= '0';
            elsif (n1 &gt; n2) then
                n1 := n1 - n2;
            elsif (n1 &lt; n2) then
                n2 := n2 - n1;
            else
                flag := false;
                busy &lt;= '0';
            end if;

            if (flag=false) then
                result &lt;= n1;
            end if;
            --calculate : while (n1 /= n2) loop
            --    if (n1&gt;n2) then
            --        n1 := n1 - n2;
            --    elsif (n2&gt;n1) then
            --        n2 := n2 - n1;
            --    --else
            --    --    flag := false;
            --    --    result &lt;= n1;
            --    end if;
            --end loop calculate;

        end if;
    end process;

end;

</code></pre>
<p>我的tb波形：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_mine.png" alt="" loading="lazy"></p>
<p>但是这样的问题是，最初的时候，a、b信号未赋值，输出为XXXX。与要求的波形不符。分析得，n1在不确定时，会给result赋值X。那么，考虑给n1、n2添加默认值0：<code>variable n1, n2 : unsigned(15 downto 0) := to_unsigned(0,16);</code>,并且修改代码。</p>
<p>修改后的代码为：</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end gcd;

architecture rtl of gcd is

begin
    process(clock)
    variable n1, n2 : unsigned(15 downto 0) := to_unsigned(0,16);
    
    begin
        if rising_edge(clock) then

            if (new_input = '1') then
                n1 := a;
                n2 := b;
                busy &lt;= '1';
            end if;

            if (n1 = 1 or n2 = 1) then -- consider when a or b = 1, then gcd is always 1
            	busy &lt;= '0';
            	result &lt;= n1;
            elsif (n1 &gt; n2) then
                n1 := n1 - n2;
            elsif (n1 &lt; n2) then
                n2 := n2 - n1;
            else
                busy &lt;= '0';
                result &lt;= n1;
            end if;

            --calculate : while (n1 /= n2) loop
            --    if (n1&gt;n2) then
            --        n1 := n1 - n2;
            --    elsif (n2&gt;n1) then
            --        n2 := n2 - n1;
            --    --else
            --    --    flag := false;
            --    --    result &lt;= n1;
            --    end if;
            --end loop calculate;
            null;
        end if;
    end process;

end;
</code></pre>
<p>修改后的tb为：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_mine_refined.png" alt="" loading="lazy"></p>
<p>盖的程序：我觉得最大的不同/优点就是使用temp的变量代替信号的作用，实现实时赋值，不用考虑信号赋值的问题。但是不需要使用tmp_a and tmp_b，故我在此处进行了注释处理。</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end;

architecture rtl of gcd is
    --signal tmp_a, tmp_b : unsigned(15 downto 0);
    
begin
    --tmp_a &lt;= a ;
    --tmp_b &lt;= b ;

    process(clock)
    variable tmp_busy : integer :=0;
    variable int_a, int_b : unsigned(15 downto 0) ;
    begin
        if rising_edge(clock) then
           if new_input='0' then
              busy&lt;= '0';
           end if;
           if new_input = '1' then
                 busy &lt;= '1' ;
                 tmp_busy :=1;
                -- int_a := tmp_a;
                 --int_b := tmp_b;
                 int_a := a;
                 int_b := b;
            end if;
            if tmp_busy = 1 then
                if int_a &gt; int_b  then
                      int_a :=int_a-int_b;
                elsif int_a&lt;int_b then
                      int_b :=int_b-int_a;
                end if;
            end if;
            if int_a = int_b then
                 busy&lt;='0';
                 tmp_busy:=0;
                 result&lt;=int_a;
            end if;
            null;
        end if;
    end process;
end;


</code></pre>
<p>波形图：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_gai.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 19, Lab 6, simulation of full adder]]></title>
        <id>https://ray-sang.github.io/post/lecture-19-lab-6-simulation-of-full-adder/</id>
        <link href="https://ray-sang.github.io/post/lecture-19-lab-6-simulation-of-full-adder/">
        </link>
        <updated>2020-10-08T05:00:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY full_adder_tb IS
END full_adder_tb;
 
ARCHITECTURE behavior OF full_adder_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT full_adder
    PORT(
         A : IN  std_logic;
         B : IN  std_logic;
         C : IN  std_logic;
         SUM : OUT  std_logic;
         CARRY : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A : std_logic := '0';
   signal B : std_logic := '0';
   signal C : std_logic := '0';

 	--Outputs
   signal SUM : std_logic;
   signal CARRY : std_logic;
   -- No clocks detected in port list. Replace &lt;clock&gt; below with 
   -- appropriate port name 
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: full_adder PORT MAP (
          A =&gt; A,
          B =&gt; B,
          C =&gt; C,
          SUM =&gt; SUM,
          CARRY =&gt; CARRY
        );
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      -- insert stimulus here 
		A &lt;= '0';
		B &lt;= '0';
		C &lt;= '0';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '0';
		C &lt;= '0';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '0';
		C &lt;= '1';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '1';
		C &lt;= '1';
		wait for 10 ns;
      wait;
   end process;

END;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_simulation_testbench.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 18, Lab 6, Full adder using half adder]]></title>
        <id>https://ray-sang.github.io/post/lecture-18-lab-6-full-adder-using-half-adder/</id>
        <link href="https://ray-sang.github.io/post/lecture-18-lab-6-full-adder-using-half-adder/">
        </link>
        <updated>2020-10-08T04:59:39.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>new project, name &quot;full_adder&quot;, new source, vhdl module, half_adder.<br>
In half_adder.vhd:</p>
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity half_adder is
port(A, B : in std_logic;
		SUM, CARRY : out std_logic);
end half_adder;

architecture Behavioral of half_adder is

begin
	SUM &lt;= A xor B;
	CARRY &lt;= A and B;
end Behavioral;
</code></pre>
<p>The same, new source, full adder.<br>
In full_adder.vhd:</p>
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity full_adder is
port(A, B, C : in std_logic;
		SUM, CARRY : out std_logic);
end full_adder;


architecture Behavioral of full_adder is

component half_adder is
port(A, B : in std_logic;
		SUM, CARRY: out std_logic);
end component;

signal sum1, sum2, carry1, carry2 : std_logic;

begin
	HA1 : half_adder 
		port map(A=&gt;A, B=&gt;B, SUM=&gt;sum1, CARRY=&gt;carry1);
	HA2 : half_adder 
		port map(A=&gt;sum1, B=&gt;C, SUM=&gt;sum2, CARRY=&gt;carry2);
	
	carry &lt;= carry1 or carry2;
	sum &lt;= sum2;

end Behavioral;

</code></pre>
<p>Technology schematic:<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_technology_schematic.png" alt="" loading="lazy"></p>
<p>RTL schematic:<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_RTL_schematic.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 17, building bigger designs from smaller ones]]></title>
        <id>https://ray-sang.github.io/post/lecture-17-building-bigger-designs-from-smaller-ones/</id>
        <link href="https://ray-sang.github.io/post/lecture-17-building-bigger-designs-from-smaller-ones/">
        </link>
        <updated>2020-10-08T04:59:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>component instantiation</li>
<li>basic example</li>
<li>full adder example using half adders</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>component instantiation</li>
<li>basic example</li>
<li>full adder example using half adders</li>
</ul>
<!-- more -->
<h2 id="component">Component</h2>
<p>When use design 'X' many times in 'Y', the problem is the repitition of designs. To make a hierarchy and a clear circuit design.</p>
<p>Components are precompiled entity-architecture pair.</p>
<p>Instantiation is selecting a component and using it as an instance in your design.</p>
<p>Port mapping is assignment of actual signals in the system to the formal ports of the component declaration.</p>
<h2 id="component-instantiation">Component instantiation</h2>
<pre><code class="language-vhdl">entity ND4 is -- NAND gate
	port(IN1, IN2, IN3, IN4 : in bit;
			Z : out bit);
end ND4;

architecture gate_arch of ND4 is
	component ND2 -- declaring the NAND gate component
		port(A ,B : in bit;
				C : out bit);
	end component;
	
	signal TEMP_1, TEMP_2 : bit; -- internal connections
begin
	U1 : ND2 port map(A =&gt; IN1, B =&gt; IN2, C =&gt; TEMP_1);
	U2 : ND2 port map(A =&gt; IN3, B =&gt; IN4, C =&gt; TEMP_2);
	U3 : ND2 port map(A =&gt; TEMP_1, B =&gt; TEMP_2, C =&gt; Z);
end gate_arch;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/component_instantiation.png" alt="" loading="lazy"></figure>
<h2 id="full-adder-using-half-adder">Full adder using half adder</h2>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_using_half_adder.png" alt="" loading="lazy"></figure>
<h3 id="half-adder-implementation">Half adder implementation</h3>
<pre><code class="language-vhdl">entity Lab6_2_halfadder is
port(A, B : in std_logic;
		sum, carry: out std_logic);
end Lab6_2_halfadder;

architecture Behavioral of Lab6_2_halfadder is
begin
	sum &lt;= A xor B;
	carry &lt;= A and B;
end Behavioral;
</code></pre>
<h3 id="full-adder">Full adder</h3>
<pre><code class="language-vhdl">-- entity part
entity Lab6_2 is
port(A, B, C : in std_logic;
		sum, carry : out std_logic);
end Lab6_2;

-- arch part
architecture Behavioral of Lab6_2 is

-- component, must be the same as halfadder
component Lab6_2_halfadder is
port(A, B : in std_logic;
		sum, carry: out std_logic);
end Lab6_2_halfadder;
end component;

-- signal
signal sum1, sum2, carry1, carry2 : std_logic;
begin
	HA1 : Lab6_2_halfadder 
		port map(A=&gt;A, B=&gt;B, sum=&gt;sum1, carry=&gt;carry1);
	HA2 : Lab6_2_halfadder 
		port map(A=&gt;sum1, B=&gt;C, sum=&gt;sum2, carry=&gt;carry2);
	
	carry &lt;= carry1 or carry2;
	sum &lt;= sum2;
	
end Behavioral;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 16, sequential circuits]]></title>
        <id>https://ray-sang.github.io/post/lecture-16-sequential-circuits/</id>
        <link href="https://ray-sang.github.io/post/lecture-16-sequential-circuits/">
        </link>
        <updated>2020-10-08T04:58:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>if-else statement</li>
<li>using if-else statement in clocked processes</li>
<li>hardware modeling examples</li>
<li>using variables as part of clocked processes</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>if-else statement</li>
<li>using if-else statement in clocked processes</li>
<li>hardware modeling examples</li>
<li>using variables as part of clocked processes</li>
</ul>
<!-- more -->
<h2 id="if-statement">if statement</h2>
<ul>
<li>If statement evaluates each condition <strong>in order</strong>.</li>
<li>Statements can be nested.</li>
</ul>
<h2 id="synchronous-reset">Synchronous reset</h2>
<p>Flip-flops are reset on the active edge of the clock when reset is held active.</p>
<pre><code class="language-vhdl">process(clk, RST)
begin
	if(clk'event and clk='1') then
		if(RST='1') then
			Q &lt;= '0';
		else
			Q &lt;= D;
		end if;
	end if;
end process;
</code></pre>
<h2 id="asynchronous-reset">Asynchronous reset</h2>
<p>Flip-flops are cleared as soon as reset is asserted.</p>
<pre><code class="language-vhdl">process(clk, RST)
begin
	if(RST='1') then
		Q &lt;= '0';
	elsif(clk'event and clk='1')
		Q &lt;= D;
	end if;
end process;
</code></pre>
<h2 id="about-flip-flop">About flip-flop</h2>
<p>Any assignment within clock statement wil generate a flip-flop, and other combinational circuitry will be generated at the 'D' input of the flip-flop.</p>
<p>An hardware modeling example:</p>
<pre><code class="language-vhdl">process(clk, reset)
begin
	if(reset='1') then
		out1 &lt;= '0';
	elsif(clk'event and clk='1') then
		if(in1='1') then
			out1 &lt;= a and b;
		else
			out1 &lt;= c and d;
		end if;
	end if;

end process;
</code></pre>
<h2 id="latch">Latch</h2>
<p>Imcompletely specified conditional expression infers a latch.</p>
<p>Latch is a combinational circuit which necessarily has feedback to hold the output to previous value for the unspecified state/conditions.</p>
<p>Avoid the inference of latches in synchronous designs. As latches infer feedback and they cause difficulties in timing analysis and test insertion applications. Most synthesizers provide warnings when latches are inferred.</p>
<ul>
<li>incompletely specified conditional expression, infers a latch</li>
</ul>
<pre><code class="language-vhdl">process(en, a)
begin
	if(en='1') then
		out1 &lt;= a;
	end if;
end process;
</code></pre>
<ul>
<li>completely specified conditional expression, infers a normal combinational circuit(MUX)</li>
</ul>
<pre><code class="language-vhdl">process(en, a)
begin
	if(en='1') then
		out1 &lt;= a;
	else
		out1 &lt;= '1';
	end if;
end process;
</code></pre>
<h2 id="an-multiple-flip-flop-example">An multiple flip-flop example</h2>
<p>Asynchronous reset.<br>
(a or b)    ---flipflop---&gt;  temp  ---flipflop---&gt;  out.<br>
Rather than <s>(a or b) ---ff---&gt; temp ---&gt; out</s>.</p>
<p>Inside the clock process, every time when using an assignment will infer a flip-flop!</p>
<p><strong>Total 2 flip-flops!</strong></p>
<pre><code class="language-vhdl">architecture var of FF is
	signal temp : std_logic;
begin
	process(clock)
	begin
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp &lt;= a or b;
			out &lt;= temp; -- end up with 2 flip-flops
		end if;
	end process;
end var;
</code></pre>
<p>So, to achieve** (a or b) ---&gt; temp   ---ff---&gt;  out**, how to adjust the code?</p>
<pre><code class="language-vhdl">architecture var of FF is
begin
	process(clock)
		variable temp : std_logic; -- note this
	begin
		temp := '0';
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp := a or b;
			out &lt;= temp; -- end up with 1 flip-flop
		end if;
	end process;
end var;
</code></pre>
<p>Consider another example:</p>
<p>Create a circuit which is sequential and has a feedback.<br>
(a and out) ---&gt; temp ---ff---&gt; out.</p>
<pre><code class="language-vhdl">architecture var of FF is
begin
	process(clock)
		variable temp : std_logic;
	begin
		temp := '0';
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp := a and out; -- note this
			out &lt;= temp;
		end if;
	end process;
end var;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 15, Lab 5, case-select simulation]]></title>
        <id>https://ray-sang.github.io/post/lecture-15-lab-5-case-select-simulation/</id>
        <link href="https://ray-sang.github.io/post/lecture-15-lab-5-case-select-simulation/">
        </link>
        <updated>2020-10-08T04:58:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY case_sel_tb IS
END case_sel_tb;
 
ARCHITECTURE behavior OF case_sel_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT case_sel
    PORT(
         A : IN  std_logic;
         B : IN  std_logic;
         C : IN  std_logic;
         D : IN  std_logic;
         sel : IN  std_logic_vector(1 downto 0);
         Y : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A : std_logic := '0';
   signal B : std_logic := '0';
   signal C : std_logic := '0';
   signal D : std_logic := '0';
   signal sel : std_logic_vector(1 downto 0) := (others =&gt; '0');

 	--Outputs
   signal Y : std_logic;
   -- No clocks detected in port list. Replace &lt;clock&gt; below with 
   -- appropriate port name 
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: case_sel PORT MAP (
          A =&gt; A,
          B =&gt; B,
          C =&gt; C,
          D =&gt; D,
          sel =&gt; sel,
          Y =&gt; Y
        );


   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      -- insert stimulus here 
		A &lt;= '1';
		B &lt;= '1';
		C &lt;= '0';
		D &lt;= '0';
		sel &lt;= &quot;00&quot;;
		wait for 10 ns;
		sel &lt;= &quot;01&quot;;
		wait for 10 ns;
		sel &lt;= &quot;10&quot;;
		wait for 10 ns;
		sel &lt;= &quot;11&quot;;
		wait for 10 ns;
		
      wait;
   end process;

END;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 14, Lab 5, case-select statement]]></title>
        <id>https://ray-sang.github.io/post/lecture-14-lab-5-case-select-statement/</id>
        <link href="https://ray-sang.github.io/post/lecture-14-lab-5-case-select-statement/">
        </link>
        <updated>2020-10-08T04:57:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity case_sel is
port(
	A : in std_logic;
	B : in std_logic;
	C : in std_logic;
	D : in std_logic;
	sel : in std_logic_vector(1 downto 0);
	Y : out std_logic
);
end case_sel;


architecture Behavioral of case_sel is

begin
process(A, B, C, D, sel)
	begin
		case sel is
			when &quot;00&quot; =&gt; Y &lt;= A;
			when &quot;01&quot; =&gt; Y &lt;= B;
			when &quot;10&quot; =&gt; Y &lt;= C;
			when &quot;11&quot; =&gt; Y &lt;= D;
			when others =&gt; Y &lt;= '0';
		end case;
	end process;
end Behavioral;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 13, Lab 4, process simulation]]></title>
        <id>https://ray-sang.github.io/post/lecture-13-lab-4-process-simulation/</id>
        <link href="https://ray-sang.github.io/post/lecture-13-lab-4-process-simulation/">
        </link>
        <updated>2020-10-08T04:57:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY if_else_tb IS
END if_else_tb;
 
ARCHITECTURE behavior OF if_else_tb IS 
 
    COMPONENT if_else
    PORT(
         A : IN  std_logic;
         B : IN  std_logic;
         C : IN  std_logic;
         D : IN  std_logic;
         sel : IN  std_logic_vector(2 downto 0);
         Y : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A : std_logic := '0';
   signal B : std_logic := '0';
   signal C : std_logic := '0';
   signal D : std_logic := '0';
   signal sel : std_logic_vector(2 downto 0) := (others =&gt; '0');

 	--Outputs
   signal Y : std_logic;
   -- No clocks detected in port list. Replace &lt;clock&gt; below with 
   -- appropriate port name 
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: if_else PORT MAP (
          A =&gt; A,
          B =&gt; B,
          C =&gt; C,
          D =&gt; D,
          sel =&gt; sel,
          Y =&gt; Y
        );


   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      -- insert stimulus here 
		A &lt;= '1';
		B &lt;= '0';
		C &lt;= '0';
		D &lt;= '1';
		sel &lt;= &quot;100&quot;;
		wait for 10 ns;
		sel &lt;= &quot;001&quot;;
		wait for 10 ns;
		sel &lt;= &quot;011&quot;;
		wait for 10 ns;
		sel &lt;= &quot;000&quot;;
		
      wait;
   end process;

END;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 12, Lab 4 - process in VHDL]]></title>
        <id>https://ray-sang.github.io/post/lecture-12-lab-4-process-in-vhdl/</id>
        <link href="https://ray-sang.github.io/post/lecture-12-lab-4-process-in-vhdl/">
        </link>
        <updated>2020-10-08T04:56:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Aim: to learn about process and if-else statement.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Aim: to learn about process and if-else statement.</p>
<!-- more -->
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity if_else is
port(
	A : in std_logic;
	B : in std_logic;
	C : in std_logic;
	D : in std_logic;
	sel : in std_logic_vector(2 downto 0);
	Y : out std_logic
);
end if_else;

architecture Behavioral of if_else is

begin
	process(A, B, C, D, sel)
	begin
		if (sel(0) = '1') then
			Y &lt;= A;
		elsif (sel(1) = '1') then
			Y &lt;= B;
		elsif (sel(2) = '1') then
			Y &lt;= C;
		else
			Y &lt;= D;
		end if;
	end process;
end Behavioral;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 11, processes and sequential statements]]></title>
        <id>https://ray-sang.github.io/post/lecture-11-processes-and-sequential-statements/</id>
        <link href="https://ray-sang.github.io/post/lecture-11-processes-and-sequential-statements/">
        </link>
        <updated>2020-10-08T04:55:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="process-rules">Process rules</h2>
<ul>
<li>Process as a whole will execute concurrently, but statements inside will execute sequentially.</li>
<li>only sequential statements can use variables</li>
</ul>
<h2 id="an-example-of-a-process">An example of a process</h2>
<pre><code class="language-vhdl">architecture SEQUENTIAL of MULTIPLE is
	signal Z, A, B, C, D : std_logic;
begin
	process(A, B, C, D) -- note 1
	begin
		Z &lt;= A and B;
		*** Z &lt;= C and D; *** -- note 2
	end process;
end SEQUENTIAL;
</code></pre>
<ul>
<li>
<p>note 1: sensitivity list. <strong>You can either have a sensitivity list or a wait statement.</strong> What are the changes of the <strong>signals</strong> that my process is sensitive to? When any one of the signals in the blankets changed, the process will be executed. Note that the process will be executed unconditionally for the first time.</p>
<ul>
<li>Also, signals in the list should be readable. For example, if  signal A is defined as <code>port(A : out std_logic);</code>, we cannot read an output.</li>
<li>If the sensitivity list triggeres the process then the process will execute again. It is a very repetitive process.</li>
</ul>
</li>
<li>
<p>note 2: Process places only one driver on a signal. Value that the signal is updated with is the last value assigned to it within the process execution.</p>
</li>
<li>
<p>It may occur an error of this design.</p>
</li>
</ul>
<h2 id="sensitivity-list">Sensitivity list</h2>
<p>Simulation runs a process when any one of the signals in the sensitivity list changes. Process should either have a &quot;sensitivity list&quot; or a &quot;wait&quot; statement at the end. Only static signal names are allowed in the sensitivity list.</p>
<p>Two syntax style:</p>
<ul>
<li>sensitivity list:</li>
</ul>
<pre><code class="language-vhdl">process(A, B)
begin
	if (A='1' or B='1') then
		Z &lt;= '1';
	else
		Z &lt;= '0';
	end if;
end process;
</code></pre>
<ul>
<li>suspend at wait:</li>
</ul>
<pre><code class="language-vhdl">process
begin
	if (A='1' or B='1') then
		Z &lt;= '1';
	else
		Z &lt;= '0';
	end if;
	
	wait on A, B; -- note here
end process;
</code></pre>
<h2 id="if-statement">If statement</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="language-vhdl">if condition1 then
	{sequential_statement};
elsif condition2 then
	{sequential_statement};
else 
	{sequential_statement};
end if;
</code></pre>
<p>If statement evaluates each condition in order.<br>
Statements can  be nested. 嵌套</p>
<h3 id="an-example">An example</h3>
<pre><code class="language-vhdl">process(A, B, C, X)
begin
	if (X = &quot;0000&quot;) then
	    Z &lt;= A;
	elsif (X &lt;= &quot;0101&quot;) then
		Z &lt;= B;
	else 
		Z &lt;= C;
	end if;
end process;
    
-- rewrite with with-select statement
process(A, B, C, X)
begin
    with X select
    	Z &lt;= A when &quot;0000&quot;,
    	     B when &quot;0101&quot;,
    		 C when others;
end process;
</code></pre>
<ul>
<li>Avoid using more than 3 levels to reduce delay.</li>
<li>When defining the condition, use parentheses to diffrenentiate levels of operations on the condition.</li>
</ul>
<h2 id="case-statement">Case statement</h2>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="language-vhdl">case expression is
	when choice1 =&gt; {statement};
    when choice2 =&gt; {statement};
    when others =&gt; {statement};
end case;
</code></pre>
<h3 id="example">Example</h3>
<p>A four multiplexer with 2 select lines.</p>
<pre><code class="language-vhdl">process(sel, a, b, c, d)
begin
	case sel is
		when 0 =&gt; y &lt;= a;
		when 1 =&gt; y &lt;= b;
		when 2 =&gt; y &lt;= c;
		when others =&gt; y &lt;= d;
	end case;
end process;
</code></pre>
<ul>
<li>Does not result in prioritized logic structure unlike the if statement.</li>
<li>Corresponds to &quot;with-select&quot; in concurrent statement.</li>
</ul>
<p>A few more rules of case statement:</p>
<pre><code class="language-vhdl">process(A, B, C, X)
begin
	case X is
		when 0 to 4 =&gt; -- a range
			Z &lt;= B;
		when 5 =&gt; -- a signal/variable
			Z &lt;= c;
		when 7 | 9 =&gt; -- a list
			Z &lt;= A;
		when others =&gt; -- others
			Z &lt;= 0;
	end case;
end process;
</code></pre>
<p>Note that</p>
<ul>
<li>Every possible value of the case expression must be covered in one and only one when clause. One choice can be covered only once(No overlap).</li>
<li>Each choice can be either a static expression or a static range, but, we cannot have a when condition that changes when it is being evaluated.</li>
</ul>
<h3 id="null-statement">Null statement</h3>
<p>Null statement does not perform any action. It can be used to indicate that when some conditions are met no action is to be performed.</p>
<p>An example</p>
<pre><code class="language-vhdl">case a is
	when &quot;00&quot; =&gt; q1 &lt;= '1';
	when &quot;01&quot; =&gt; q2 &lt;= '1';
	when &quot;10&quot; =&gt; q3 &lt;= '1';
	when others &lt;= null;
end case;
</code></pre>
<h2 id="comparing-if-and-case-statement">Comparing if and case statement</h2>
<p>&quot;if&quot; statement produces priority-encoded logic, while &quot;case&quot; produces parallel logic.</p>
<h2 id="a-short-introduction-to-clock">A short introduction to clock</h2>
<pre><code class="language-vhdl">process(clk)
begin
	if(clk'event and clk='1') then
		Q &lt;= D;
	end if;
end process;
</code></pre>
<p><em><strong>important: if(clk'event) should be the last one if statement in the process.</strong></em></p>
]]></content>
    </entry>
</feed>