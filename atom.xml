<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ray-sang.github.io</id>
    <title>Ray&apos;s Space</title>
    <updated>2020-10-20T12:49:29.027Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ray-sang.github.io"/>
    <link rel="self" href="https://ray-sang.github.io/atom.xml"/>
    <subtitle>Plain living and high thicking</subtitle>
    <logo>https://ray-sang.github.io/images/avatar.png</logo>
    <icon>https://ray-sang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Ray&apos;s Space</rights>
    <entry>
        <title type="html"><![CDATA[如何在LaTeX中插入子图（subfigure包）]]></title>
        <id>https://ray-sang.github.io/post/ru-he-zai-latex-zhong-cha-ru-zi-tu-subfigure-bao/</id>
        <link href="https://ray-sang.github.io/post/ru-he-zai-latex-zhong-cha-ru-zi-tu-subfigure-bao/">
        </link>
        <updated>2020-10-20T12:15:05.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="预期效果">预期效果</h1>
<p>在LaTeX中插入图片的时候，希望一个figure能够有多个subfigure，并且用(a)(b)(c)的形式标号，有独立的子图标题和主图标题，排版格式美观。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="预期效果">预期效果</h1>
<p>在LaTeX中插入图片的时候，希望一个figure能够有多个subfigure，并且用(a)(b)(c)的形式标号，有独立的子图标题和主图标题，排版格式美观。</p>
<!-- more -->
<p>在这里放上单张图片的插入方法：</p>
<pre><code class="language-latex">\usepackage{graphicx}%插入图片所需

%-----------------------------------------------------------%
\begin{figure}
\centering
\includegraphics[height=4.5cm,width=9.5cm]{111.eps}
\caption{pic1}
\label{2}
\end{figure}

% using scale
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.3]{figures/schematic.png}
        \caption{\centering The schematic of simulation}
        \label{fig:schematic}
\end{figure}
</code></pre>
<h1 id="第一种插入子图的方法">第一种插入子图的方法</h1>
<p>利用subfigure排版，放置多张图片。</p>
<p>我个人会在<code>settings.tex</code>中，使用宏包：</p>
<pre><code class="language-latex">\usepackage{graphicx}
\usepackage{subfigure}
</code></pre>
<p>放置子图的代码如下：</p>
<pre><code class="language-latex">\begin{figure}[htbp]
 \centering
     \subfigure[Step 2]{ % []内为子图标题
        \begin{minipage}[t]{0.2\linewidth}
        \centering
            \includegraphics[width=1in]{figures/s1.png}
             \label{fig:step2} % 子图label
         \end{minipage}
         } % if add a new line here, figures will be seperated! %如果在此处分行，子图也会分行
    \subfigure[Step 3]{
        \begin{minipage}[t]{0.2\linewidth}
        \centering
            \includegraphics[width=1in]{figures/s2.png}
            \label{fig:step3}
        \end{minipage}
        }
    \subfigure[Step 4]{
    \begin{minipage}[t]{0.2\linewidth}
    \centering
        \includegraphics[width=1in]{figures/s3.png}
        \label{fig:step4}
    \end{minipage}
    }
    \subfigure[Step 6]{
    \begin{minipage}[t]{0.2\linewidth}
    \centering
        \includegraphics[width=1in]{figures/s6.png}
        \label{fig:step6}
    \end{minipage}
    }
\centering
\caption{The main steps}
\label{fig:Steps}
\end{figure}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/subfigure_latex_1.png" alt="" loading="lazy"></figure>
<p>其中<code>0.25\linewidth</code>或<code>0.25\linewidth</code>是你插入图片的幅度（我理解为这副图的宽占1/4行，你下张图并排插入的话需要从1/4行处往后开始插），相当于0.25倍的当前latex中规定的一行的长度。width=1in是指图片的宽度。它可以在一个大图的框架里面插入多个小图，自动编号为a,b,c,d....并对小图分别描述。</p>
<p>但是，如果加入回车：</p>
<pre><code class="language-latex">\usepackage{graphicx}
\usepackage{subfigure}
</code></pre>
<p>放置子图的代码如下：</p>
<pre><code class="language-latex">\begin{figure}[htbp]
 \centering
     \subfigure[Step 2]{ % []内为子图标题
        \begin{minipage}[t]{0.2\linewidth}
        \centering
            \includegraphics[width=1in]{figures/s1.png}
             \label{fig:step2} % 子图label
         \end{minipage}
         } % if add a new line here, figures will be seperated! %如果在此处分行，子图也会分行
          \quad \quad % 增加图片横向间距
    \subfigure[Step 3]{
        \begin{minipage}[t]{0.2\linewidth}
        \centering
            \includegraphics[width=1in]{figures/s2.png}
            \label{fig:step3}
        \end{minipage}
        }

                    
            % 这个回车很重要 \quad也可以
    \subfigure[Step 4]{
    \begin{minipage}[t]{0.2\linewidth}
    \centering
        \includegraphics[width=1in]{figures/s3.png}
        \label{fig:step4}
    \end{minipage}
    }
     \quad \quad 
    \subfigure[Step 6]{
    \begin{minipage}[t]{0.2\linewidth}
    \centering
        \includegraphics[width=1in]{figures/s6.png}
        \label{fig:step6}
    \end{minipage}
    }
\centering
\caption{The main steps}
\label{fig:Steps}
\end{figure}
</code></pre>
<p>那么图片的呈现形式就是：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/subfigure_latex_2.png" alt="" loading="lazy"></p>
<p>既能将图片分成四个小图片，也能对四个小图片分别进行描述。</p>
<h1 id="现在流行用subfig包代替subfigure">现在流行用subfig包代替subfigure？</h1>
<p>注意把代码中的\subfigure改成\subfloat.</p>
<p>注意subfig包和subfigure包不能共存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在LaTeX全局修改字体字间距]]></title>
        <id>https://ray-sang.github.io/post/ru-he-zai-latex-quan-ju-xiu-gai-zi-ti-zi-jian-ju/</id>
        <link href="https://ray-sang.github.io/post/ru-he-zai-latex-quan-ju-xiu-gai-zi-ti-zi-jian-ju/">
        </link>
        <updated>2020-10-20T08:36:31.000Z</updated>
        <summary type="html"><![CDATA[<p>英文适用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>英文适用。</p>
<!-- more -->
<pre><code class="language-latex">\documentclass{article}

\usepackage{fontspec}
\defaultfontfeatures{LetterSpace=2}
\setmainfont{Times New Roman}

\usepackage{lipsum}
\begin{document}
\lipsum[1]
\end{document}

</code></pre>
<p>来源：https://tex.stackexchange.com/questions/62346/enlarging-tracking-letter-spacing</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020/10/12 Monday]]></title>
        <id>https://ray-sang.github.io/post/20201012-monday/</id>
        <link href="https://ray-sang.github.io/post/20201012-monday/">
        </link>
        <updated>2020-10-12T10:24:41.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>回顾</p>
<ul>
<li>formidable</li>
<li>hose</li>
<li>plaster</li>
<li>astrology</li>
<li>credible</li>
<li>dredge</li>
<li>swamp</li>
<li>siesta</li>
<li>crescent</li>
<li>skew</li>
<li>coffer</li>
<li>subsidy</li>
<li>crescent</li>
<li>centennial</li>
<li>censure</li>
<li>odour</li>
<li>audacious</li>
<li>stint</li>
<li>arboreal</li>
<li>absenteeism</li>
<li>clench</li>
<li>aggravation</li>
<li>discriminate</li>
<li>alienation</li>
<li>fauna</li>
<li>avalanche</li>
<li>cosset</li>
<li>silt</li>
<li>acumen</li>
</ul>
<p>新词</p>
<ul>
<li>
<p>primarily</p>
<ul>
<li>The advertisement is aimed primarily at housewives.</li>
</ul>
</li>
<li>
<p>beverage n. 饮料</p>
<ul>
<li>alcoholic beverages</li>
</ul>
</li>
<li>
<p>harridan n. 凶恶的老妇;老巫婆</p>
<ul>
<li>She seemed an infuriating harridan sometimes.</li>
</ul>
</li>
<li>
<p>backbone n. 脊椎,骨干;支柱 spine</p>
<ul>
<li>Agriculture forms the backbone of the country's economy.</li>
</ul>
</li>
<li>
<p>ventilation n. 空气流通;通风设备</p>
<ul>
<li>ventilate</li>
</ul>
</li>
<li>
<p>fossil n. 化石;老人;老顽童,老古董</p>
<ul>
<li>He found a piece of fossil of an ancient bird.</li>
</ul>
</li>
<li>
<p>competent</p>
</li>
<li>
<p>grip v. 紧握,紧抓 n. 紧握;把手,夹具;支配,控制</p>
<ul>
<li>He gripped the rope tightly and pulled the boat to the shore.</li>
</ul>
</li>
<li>
<p>bibliography n. 参考书目,书目</p>
<ul>
<li>She provides a detailed bibliography of her thesis for readers to find souces of the reference.</li>
</ul>
</li>
<li>
<p>graphology n. 笔迹学</p>
<ul>
<li>graphologist 笔迹学家</li>
</ul>
</li>
<li>
<p>flaw n. 错误,缺点;裂痕,瑕疵</p>
<ul>
<li>drawback shortpoint</li>
</ul>
</li>
<li>
<p>aesthetic adj. 美学的;审美的</p>
<ul>
<li>This oil painting has little aesthetic value.</li>
<li>esthetic adj. 审美的</li>
</ul>
</li>
<li>
<p>endorse v. 认可,赞同</p>
<ul>
<li>The proposal for an educational reform was endorsed by the state coucil.</li>
<li>endorser 背书人</li>
<li>to endorse 背书</li>
</ul>
</li>
<li>
<p>apparatus n. 装置,器具,机构,组织</p>
<ul>
<li>electric apparatus</li>
</ul>
</li>
<li>
<p>medieval  中世纪的 中古时代的</p>
<ul>
<li>medieval attitude 守旧的态度</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[硬件仿真课程作业-gcd]]></title>
        <id>https://ray-sang.github.io/post/ying-jian-fang-zhen-ke-cheng-zuo-ye-gcd/</id>
        <link href="https://ray-sang.github.io/post/ying-jian-fang-zhen-ke-cheng-zuo-ye-gcd/">
        </link>
        <updated>2020-10-11T12:38:14.000Z</updated>
        <summary type="html"><![CDATA[<p>要求：<br>
设计一个电路，实现最大公约数计算。</p>
]]></summary>
        <content type="html"><![CDATA[<p>要求：<br>
设计一个电路，实现最大公约数计算。</p>
<!-- more -->
<p>例程对应的entity结构为：</p>
<pre><code class="language-vhdl">entity gcd is

    port

    (

        clock, new_input : in std_logic;

        a, b   : in  unsigned(15 downto 0);

        result : out unsigned(15 downto 0):=to_unsigned(0,16);

        busy   : out std_logic

    );

end;
</code></pre>
<p>各个信号功能说明如下：<br>
Clock：时钟，在它的上升沿作用下进行数据计算<br>
New_input：该信号=’1’时，表示需要在clock上升沿输入待计算的两个数a和b<br>
Result: 运算结果，当busy=‘0‘时输出最新的运算结果<br>
Busy: 表明当前电路处于运算中，还是运算完成，它为‘1’的时候表明运算尚未完成，此时result的内容不可用，但它为’0’时，表明运算结束，此时result存放的是运算结果（最近一次new_input=‘1‘时输入数据a和b的最大公约数）</p>
<p>tb的结果应该为：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd.png" alt="" loading="lazy"></p>
<p>我的程序：</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end gcd;

architecture rtl of gcd is
    -- fill you code here
begin
    process(clock)
    -- fill your code
    variable flag : boolean := false;
    variable n1, n2 : unsigned(15 downto 0);
    
    begin
        if rising_edge(clock) then

            if (new_input = '1') then
                n1 := a;
                n2 := b;
                busy &lt;= '1';
                flag := true;
            end if;

            if (n1 = 1 or n2 = 1) then -- consider when a or b = 1, then gcd is always 1
            	flag := false;
            	busy &lt;= '0';
            elsif (n1 &gt; n2) then
                n1 := n1 - n2;
            elsif (n1 &lt; n2) then
                n2 := n2 - n1;
            else
                flag := false;
                busy &lt;= '0';
            end if;

            if (flag=false) then
                result &lt;= n1;
            end if;
            --calculate : while (n1 /= n2) loop
            --    if (n1&gt;n2) then
            --        n1 := n1 - n2;
            --    elsif (n2&gt;n1) then
            --        n2 := n2 - n1;
            --    --else
            --    --    flag := false;
            --    --    result &lt;= n1;
            --    end if;
            --end loop calculate;

        end if;
    end process;

end;

</code></pre>
<p>我的tb波形：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_mine.png" alt="" loading="lazy"></p>
<p>但是这样的问题是，最初的时候，a、b信号未赋值，输出为XXXX。与要求的波形不符。分析得，n1在不确定时，会给result赋值X。那么，考虑给n1、n2添加默认值0：<code>variable n1, n2 : unsigned(15 downto 0) := to_unsigned(0,16);</code>,并且修改代码。</p>
<p>修改后的代码为：</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end gcd;

architecture rtl of gcd is

begin
    process(clock)
    variable n1, n2 : unsigned(15 downto 0) := to_unsigned(0,16);
    
    begin
        if rising_edge(clock) then

            if (new_input = '1') then
                n1 := a;
                n2 := b;
                busy &lt;= '1';
            end if;

            if (n1 = 1 or n2 = 1) then -- consider when a or b = 1, then gcd is always 1
            	busy &lt;= '0';
            	result &lt;= n1;
            elsif (n1 &gt; n2) then
                n1 := n1 - n2;
            elsif (n1 &lt; n2) then
                n2 := n2 - n1;
            else
                busy &lt;= '0';
                result &lt;= n1;
            end if;

            --calculate : while (n1 /= n2) loop
            --    if (n1&gt;n2) then
            --        n1 := n1 - n2;
            --    elsif (n2&gt;n1) then
            --        n2 := n2 - n1;
            --    --else
            --    --    flag := false;
            --    --    result &lt;= n1;
            --    end if;
            --end loop calculate;
            null;
        end if;
    end process;

end;
</code></pre>
<p>修改后的tb为：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_mine_refined.png" alt="" loading="lazy"></p>
<p>盖的程序：我觉得最大的不同/优点就是使用temp的变量代替信号的作用，实现实时赋值，不用考虑信号赋值的问题。但是不需要使用tmp_a and tmp_b，故我在此处进行了注释处理。</p>
<pre><code class="language-vhdl">library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd is
    port 
    (
        clock, new_input : in std_logic;
        a, b   : in  unsigned(15 downto 0);
        result : out unsigned(15 downto 0):=to_unsigned(0,16);
        busy   : out std_logic
    );
end;

architecture rtl of gcd is
    --signal tmp_a, tmp_b : unsigned(15 downto 0);
    
begin
    --tmp_a &lt;= a ;
    --tmp_b &lt;= b ;

    process(clock)
    variable tmp_busy : integer :=0;
    variable int_a, int_b : unsigned(15 downto 0) ;
    begin
        if rising_edge(clock) then
           if new_input='0' then
              busy&lt;= '0';
           end if;
           if new_input = '1' then
                 busy &lt;= '1' ;
                 tmp_busy :=1;
                -- int_a := tmp_a;
                 --int_b := tmp_b;
                 int_a := a;
                 int_b := b;
            end if;
            if tmp_busy = 1 then
                if int_a &gt; int_b  then
                      int_a :=int_a-int_b;
                elsif int_a&lt;int_b then
                      int_b :=int_b-int_a;
                end if;
            end if;
            if int_a = int_b then
                 busy&lt;='0';
                 tmp_busy:=0;
                 result&lt;=int_a;
            end if;
            null;
        end if;
    end process;
end;


</code></pre>
<p>波形图：<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/vhdl_homework_gcd_gai.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 19, Lab 6, simulation of full adder]]></title>
        <id>https://ray-sang.github.io/post/lecture-19-lab-6-simulation-of-full-adder/</id>
        <link href="https://ray-sang.github.io/post/lecture-19-lab-6-simulation-of-full-adder/">
        </link>
        <updated>2020-10-08T05:00:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY full_adder_tb IS
END full_adder_tb;
 
ARCHITECTURE behavior OF full_adder_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT full_adder
    PORT(
         A : IN  std_logic;
         B : IN  std_logic;
         C : IN  std_logic;
         SUM : OUT  std_logic;
         CARRY : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A : std_logic := '0';
   signal B : std_logic := '0';
   signal C : std_logic := '0';

 	--Outputs
   signal SUM : std_logic;
   signal CARRY : std_logic;
   -- No clocks detected in port list. Replace &lt;clock&gt; below with 
   -- appropriate port name 
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: full_adder PORT MAP (
          A =&gt; A,
          B =&gt; B,
          C =&gt; C,
          SUM =&gt; SUM,
          CARRY =&gt; CARRY
        );
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      -- insert stimulus here 
		A &lt;= '0';
		B &lt;= '0';
		C &lt;= '0';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '0';
		C &lt;= '0';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '0';
		C &lt;= '1';
		wait for 10 ns;
		
		A &lt;= '1';
		B &lt;= '1';
		C &lt;= '1';
		wait for 10 ns;
      wait;
   end process;

END;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_simulation_testbench.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 18, Lab 6, Full adder using half adder]]></title>
        <id>https://ray-sang.github.io/post/lecture-18-lab-6-full-adder-using-half-adder/</id>
        <link href="https://ray-sang.github.io/post/lecture-18-lab-6-full-adder-using-half-adder/">
        </link>
        <updated>2020-10-08T04:59:39.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>new project, name &quot;full_adder&quot;, new source, vhdl module, half_adder.<br>
In half_adder.vhd:</p>
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity half_adder is
port(A, B : in std_logic;
		SUM, CARRY : out std_logic);
end half_adder;

architecture Behavioral of half_adder is

begin
	SUM &lt;= A xor B;
	CARRY &lt;= A and B;
end Behavioral;
</code></pre>
<p>The same, new source, full adder.<br>
In full_adder.vhd:</p>
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity full_adder is
port(A, B, C : in std_logic;
		SUM, CARRY : out std_logic);
end full_adder;


architecture Behavioral of full_adder is

component half_adder is
port(A, B : in std_logic;
		SUM, CARRY: out std_logic);
end component;

signal sum1, sum2, carry1, carry2 : std_logic;

begin
	HA1 : half_adder 
		port map(A=&gt;A, B=&gt;B, SUM=&gt;sum1, CARRY=&gt;carry1);
	HA2 : half_adder 
		port map(A=&gt;sum1, B=&gt;C, SUM=&gt;sum2, CARRY=&gt;carry2);
	
	carry &lt;= carry1 or carry2;
	sum &lt;= sum2;

end Behavioral;

</code></pre>
<p>Technology schematic:<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_technology_schematic.png" alt="" loading="lazy"></p>
<p>RTL schematic:<br>
<img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_RTL_schematic.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 17, building bigger designs from smaller ones]]></title>
        <id>https://ray-sang.github.io/post/lecture-17-building-bigger-designs-from-smaller-ones/</id>
        <link href="https://ray-sang.github.io/post/lecture-17-building-bigger-designs-from-smaller-ones/">
        </link>
        <updated>2020-10-08T04:59:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>component instantiation</li>
<li>basic example</li>
<li>full adder example using half adders</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>component instantiation</li>
<li>basic example</li>
<li>full adder example using half adders</li>
</ul>
<!-- more -->
<h2 id="component">Component</h2>
<p>When use design 'X' many times in 'Y', the problem is the repitition of designs. To make a hierarchy and a clear circuit design.</p>
<p>Components are precompiled entity-architecture pair.</p>
<p>Instantiation is selecting a component and using it as an instance in your design.</p>
<p>Port mapping is assignment of actual signals in the system to the formal ports of the component declaration.</p>
<h2 id="component-instantiation">Component instantiation</h2>
<pre><code class="language-vhdl">entity ND4 is -- NAND gate
	port(IN1, IN2, IN3, IN4 : in bit;
			Z : out bit);
end ND4;

architecture gate_arch of ND4 is
	component ND2 -- declaring the NAND gate component
		port(A ,B : in bit;
				C : out bit);
	end component;
	
	signal TEMP_1, TEMP_2 : bit; -- internal connections
begin
	U1 : ND2 port map(A =&gt; IN1, B =&gt; IN2, C =&gt; TEMP_1);
	U2 : ND2 port map(A =&gt; IN3, B =&gt; IN4, C =&gt; TEMP_2);
	U3 : ND2 port map(A =&gt; TEMP_1, B =&gt; TEMP_2, C =&gt; Z);
end gate_arch;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/component_instantiation.png" alt="" loading="lazy"></figure>
<h2 id="full-adder-using-half-adder">Full adder using half adder</h2>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/Ray-Sang/picsbed1/master/picgo/full_adder_using_half_adder.png" alt="" loading="lazy"></figure>
<h3 id="half-adder-implementation">Half adder implementation</h3>
<pre><code class="language-vhdl">entity Lab6_2_halfadder is
port(A, B : in std_logic;
		sum, carry: out std_logic);
end Lab6_2_halfadder;

architecture Behavioral of Lab6_2_halfadder is
begin
	sum &lt;= A xor B;
	carry &lt;= A and B;
end Behavioral;
</code></pre>
<h3 id="full-adder">Full adder</h3>
<pre><code class="language-vhdl">-- entity part
entity Lab6_2 is
port(A, B, C : in std_logic;
		sum, carry : out std_logic);
end Lab6_2;

-- arch part
architecture Behavioral of Lab6_2 is

-- component, must be the same as halfadder
component Lab6_2_halfadder is
port(A, B : in std_logic;
		sum, carry: out std_logic);
end Lab6_2_halfadder;
end component;

-- signal
signal sum1, sum2, carry1, carry2 : std_logic;
begin
	HA1 : Lab6_2_halfadder 
		port map(A=&gt;A, B=&gt;B, sum=&gt;sum1, carry=&gt;carry1);
	HA2 : Lab6_2_halfadder 
		port map(A=&gt;sum1, B=&gt;C, sum=&gt;sum2, carry=&gt;carry2);
	
	carry &lt;= carry1 or carry2;
	sum &lt;= sum2;
	
end Behavioral;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 16, sequential circuits]]></title>
        <id>https://ray-sang.github.io/post/lecture-16-sequential-circuits/</id>
        <link href="https://ray-sang.github.io/post/lecture-16-sequential-circuits/">
        </link>
        <updated>2020-10-08T04:58:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>if-else statement</li>
<li>using if-else statement in clocked processes</li>
<li>hardware modeling examples</li>
<li>using variables as part of clocked processes</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="points-to-discuss">Points to discuss</h2>
<ul>
<li>if-else statement</li>
<li>using if-else statement in clocked processes</li>
<li>hardware modeling examples</li>
<li>using variables as part of clocked processes</li>
</ul>
<!-- more -->
<h2 id="if-statement">if statement</h2>
<ul>
<li>If statement evaluates each condition <strong>in order</strong>.</li>
<li>Statements can be nested.</li>
</ul>
<h2 id="synchronous-reset">Synchronous reset</h2>
<p>Flip-flops are reset on the active edge of the clock when reset is held active.</p>
<pre><code class="language-vhdl">process(clk, RST)
begin
	if(clk'event and clk='1') then
		if(RST='1') then
			Q &lt;= '0';
		else
			Q &lt;= D;
		end if;
	end if;
end process;
</code></pre>
<h2 id="asynchronous-reset">Asynchronous reset</h2>
<p>Flip-flops are cleared as soon as reset is asserted.</p>
<pre><code class="language-vhdl">process(clk, RST)
begin
	if(RST='1') then
		Q &lt;= '0';
	elsif(clk'event and clk='1')
		Q &lt;= D;
	end if;
end process;
</code></pre>
<h2 id="about-flip-flop">About flip-flop</h2>
<p>Any assignment within clock statement wil generate a flip-flop, and other combinational circuitry will be generated at the 'D' input of the flip-flop.</p>
<p>An hardware modeling example:</p>
<pre><code class="language-vhdl">process(clk, reset)
begin
	if(reset='1') then
		out1 &lt;= '0';
	elsif(clk'event and clk='1') then
		if(in1='1') then
			out1 &lt;= a and b;
		else
			out1 &lt;= c and d;
		end if;
	end if;

end process;
</code></pre>
<h2 id="latch">Latch</h2>
<p>Imcompletely specified conditional expression infers a latch.</p>
<p>Latch is a combinational circuit which necessarily has feedback to hold the output to previous value for the unspecified state/conditions.</p>
<p>Avoid the inference of latches in synchronous designs. As latches infer feedback and they cause difficulties in timing analysis and test insertion applications. Most synthesizers provide warnings when latches are inferred.</p>
<ul>
<li>incompletely specified conditional expression, infers a latch</li>
</ul>
<pre><code class="language-vhdl">process(en, a)
begin
	if(en='1') then
		out1 &lt;= a;
	end if;
end process;
</code></pre>
<ul>
<li>completely specified conditional expression, infers a normal combinational circuit(MUX)</li>
</ul>
<pre><code class="language-vhdl">process(en, a)
begin
	if(en='1') then
		out1 &lt;= a;
	else
		out1 &lt;= '1';
	end if;
end process;
</code></pre>
<h2 id="an-multiple-flip-flop-example">An multiple flip-flop example</h2>
<p>Asynchronous reset.<br>
(a or b)    ---flipflop---&gt;  temp  ---flipflop---&gt;  out.<br>
Rather than <s>(a or b) ---ff---&gt; temp ---&gt; out</s>.</p>
<p>Inside the clock process, every time when using an assignment will infer a flip-flop!</p>
<p><strong>Total 2 flip-flops!</strong></p>
<pre><code class="language-vhdl">architecture var of FF is
	signal temp : std_logic;
begin
	process(clock)
	begin
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp &lt;= a or b;
			out &lt;= temp; -- end up with 2 flip-flops
		end if;
	end process;
end var;
</code></pre>
<p>So, to achieve** (a or b) ---&gt; temp   ---ff---&gt;  out**, how to adjust the code?</p>
<pre><code class="language-vhdl">architecture var of FF is
begin
	process(clock)
		variable temp : std_logic; -- note this
	begin
		temp := '0';
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp := a or b;
			out &lt;= temp; -- end up with 1 flip-flop
		end if;
	end process;
end var;
</code></pre>
<p>Consider another example:</p>
<p>Create a circuit which is sequential and has a feedback.<br>
(a and out) ---&gt; temp ---ff---&gt; out.</p>
<pre><code class="language-vhdl">architecture var of FF is
begin
	process(clock)
		variable temp : std_logic;
	begin
		temp := '0';
		if(reset='1') then
			out &lt;= '0';
		elsif(rising_edge(clock)) then
			temp := a and out; -- note this
			out &lt;= temp;
		end if;
	end process;
end var;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 15, Lab 5, case-select simulation]]></title>
        <id>https://ray-sang.github.io/post/lecture-15-lab-5-case-select-simulation/</id>
        <link href="https://ray-sang.github.io/post/lecture-15-lab-5-case-select-simulation/">
        </link>
        <updated>2020-10-08T04:58:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY case_sel_tb IS
END case_sel_tb;
 
ARCHITECTURE behavior OF case_sel_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT case_sel
    PORT(
         A : IN  std_logic;
         B : IN  std_logic;
         C : IN  std_logic;
         D : IN  std_logic;
         sel : IN  std_logic_vector(1 downto 0);
         Y : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A : std_logic := '0';
   signal B : std_logic := '0';
   signal C : std_logic := '0';
   signal D : std_logic := '0';
   signal sel : std_logic_vector(1 downto 0) := (others =&gt; '0');

 	--Outputs
   signal Y : std_logic;
   -- No clocks detected in port list. Replace &lt;clock&gt; below with 
   -- appropriate port name 
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: case_sel PORT MAP (
          A =&gt; A,
          B =&gt; B,
          C =&gt; C,
          D =&gt; D,
          sel =&gt; sel,
          Y =&gt; Y
        );


   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      -- insert stimulus here 
		A &lt;= '1';
		B &lt;= '1';
		C &lt;= '0';
		D &lt;= '0';
		sel &lt;= &quot;00&quot;;
		wait for 10 ns;
		sel &lt;= &quot;01&quot;;
		wait for 10 ns;
		sel &lt;= &quot;10&quot;;
		wait for 10 ns;
		sel &lt;= &quot;11&quot;;
		wait for 10 ns;
		
      wait;
   end process;

END;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture 14, Lab 5, case-select statement]]></title>
        <id>https://ray-sang.github.io/post/lecture-14-lab-5-case-select-statement/</id>
        <link href="https://ray-sang.github.io/post/lecture-14-lab-5-case-select-statement/">
        </link>
        <updated>2020-10-08T04:57:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity case_sel is
port(
	A : in std_logic;
	B : in std_logic;
	C : in std_logic;
	D : in std_logic;
	sel : in std_logic_vector(1 downto 0);
	Y : out std_logic
);
end case_sel;


architecture Behavioral of case_sel is

begin
process(A, B, C, D, sel)
	begin
		case sel is
			when &quot;00&quot; =&gt; Y &lt;= A;
			when &quot;01&quot; =&gt; Y &lt;= B;
			when &quot;10&quot; =&gt; Y &lt;= C;
			when &quot;11&quot; =&gt; Y &lt;= D;
			when others =&gt; Y &lt;= '0';
		end case;
	end process;
end Behavioral;

</code></pre>
]]></content>
    </entry>
</feed>